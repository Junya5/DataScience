# block-chains-learning-notes
## 《精通比特币》学习笔记
### 快速术语检索


### 什么是比特币
- 比特币是由一系列概念和技术作为基础构建的数字货币生态系统。比特币是其中的货币单位。
- 比特币没有实体，隐含在转账记录当中，拥有证明其控制权的密钥就可以发送比特币
- 比特币是一个点对点网络系统，币通过挖矿产生的。系统包含提高挖矿难度的协议，使得平均每10分钟只有一个区块产生.还规定每四年新币开采量减半，使得币的最终开采量将达到2100万。故而是一种通货紧缩货币。
- **比特币集密码学和分布式系统之大成，由以下四个关键的创新点构成** *（对于我们构建新类型的区块链来说具有很重要的参考价值）*
  1. 一个去中心化的点对点网络（比特币协议）
  2. 一个公共的交易账簿（区块链）
  3. **一个去中心化的数学和确定性的货币发行（分布式挖矿）**  
    ***（对于我们来说这一部分需要更加深入详细的了解以创造一种适用于信息价值体现与处理的新的货币发行系统）***  
  4. 一个去中心化的交易系统（交易脚本）

#### 比特币之前的数字货币
**两个问题**
- 我能相信这笔钱可信么？
- 双重支付问题，我能确定没有人声明这笔钱是他们的么？  
**早期数字货币的特点**
- 基于密码学的加密数字签名使一个用户签署一项能够提供其资产所有权按证明的数字资产或数字交易。也可以解决双重支付的问题。
- 早期的数字通货是中心化的，使用一个中央结算处理所有的顶起交易  
#### 比特币客户端类型
- 完整客户端  
  储存所有比特币交易的整个交易历史的客户端；管理用户钱包；可以直接在比特币网络上开始交易。处理这协议的各个方面，不依赖于任何其它的服务器或者第三方服务。
- 轻量级客户端  
  储存用户的钱包，但依赖第三方服务器进行比特币交易，进入比特币网络
- 在线客户端  
  通过网络浏览器在第三方服务器上访问和储存该用户的钱包。完全依赖于第三方服务器。  
- *移动客户端*  
  基于移动设备的如Android或者ios操作系统。既可以作为完整客户端运行，也可以作为轻量级或者在线客户端。有一些是与在线客户端或者桌面客户端同步的，也就是跨平台跨设备但是共同拥有同一个资金源的钱包。  
  ***移动客户端终将成为发展趋势，多平台之间的管理与同步也将成为我们参考与发展的重要内容之一，在第一次测试稳定运行之后；可以考虑接着现有的代码迅速构造一个安卓程序利用虚拟机或者真机参与至其中来。***

### 比特币的原理  
#### 比特币的交易
告知全网比特币的的持有者已经授权把比特币转账给其他人。持有者可以进行同样的授权，转移给比特币链中的其他人；也就是说比特币就是存在于记录了这样一笔一笔账目的账本，这些账本是被储存在区块当中的，而区块又从前到后形成了区块链，区块链的不可逆转性保证了这些账本是可信的，从而通过查询区块链中储存的比特币就可以知道你到底还拥有多少可以授权转账给其他人的比特币也就是你的余额。  
- 比特币的每一笔交易可以包括多个输入和输出，比如你要输出2.0个比特币，但是你并没有一笔超过2.0比特币的输入，只有1.2 0.7 1.1三笔输入，那么账户将会将这三笔输入输出一个2.0比特币到收款账户，剩余的1.0比特币将会生成另外一个输出进入你自己的账户也就是常规意义上所谓的找零，但是往往总输出可能会略低于总输入，***其中少去的一点点差额进入了矿工的账户，也是矿工的收入来源（在我的构想中，这将成为在我们新设计的系统中矿工的主要收入来源）***
- 比特币的交易包含了每一笔被转移的比特币的所有权证明（以所有者的数字签名形式存在），可以被任何人独立验证。在比特币的消费中，只是签署一笔交易转移一笔之前交易得到的比特币到以比特币地址标识的新所有者。而追随着某笔交易可以回溯到这笔交易所转移的比特币诞生之日。同样的交易过程中不会有比特币被消耗。
- 如何保证这笔交易是我愿意进行的以及如何确保是这笔交易的对象收到的这次交易的比特币；每一笔的交易的输出需要持有者的密钥确认（比如说信用卡的签名），同样的每一笔交易的收入对象也需要一个密钥来确认才能向网络证明他拥有了这笔钱。而网络会广播这条交易信息直到下一个新区块产生并被写入该区块；  
- 比特币交易的生命周期从它被创建的的一刻起，比特币可以被任何人创建，本质上是制定一个或几个以往的交易作为资金来源，一旦被资金所有者签名，如果是合法创建并被资金来源的交易所有者签名的。之后会被一个或多个签名加密，这些签名标志着该交易指向的比特币资金的使用许可，之后该交易被广播到网络中，被每一个节点验证，直到被绝大多数结点接收，最终被一个挖矿节点验证，直到被添加到一个区块中。
- 比特币交易的数据是经过签名的不包含任何机密信息，可以通过任何一个为机密网络进行传播只要其可以被最终传播到一个比特币网络的比特币节点。同样的当一笔交易被一个节点验证是有效的发起者将会收到一条交易有效并且被接受的有效信息同样的一旦结点确认一个交易是有效的，这个交易将会被传播到改节点所连接的其它节点。
##### 比特币交易的结构
- 引用书中5.3章节 5-1的图  交易的锁定时间，0意味着立即执行，0-5亿意味着区块高度，5亿以上 指unix纪元时间戳（1970.1.1以来的秒数） 相当于生效期后延。
- 交易的基本单位是未经使用的一个交易输出即UTXO 若一个UTXO比输出大其会被作为一个整体消耗掉并声称零头，这些零头也是一个UTXO。一个交易可以是任意数值，但必须来自于可用的UTXO。
- 每一笔交易输出都会被账簿记下来，去除OP_RETURN 数据输出，几乎所有的输出都会产生新的UTXO，所有的UTXO会被每一个全集欸但比特币客户端在一个储存于内存中的数据库所追踪，新的交易从UTXO中消耗（支付）一个或多个输出。  输出包含一定量的比特币和一个锁定脚本。
- 支付条件即锁定脚本把输出锁在一个特定的比特币地址上，也就是进入了此地址的钱包，当这个钱包想要使用这个交易的进行输出的时候需要使用私钥进行输出。
- 交易的输入，是一个指向UTXO的指针，需要一个解锁脚本，通常是一个签名来证明对锁在脚本中的比特币的所有权
- 交易费 交易费与交易的尺寸有关系，交易费被挖出这个区块的矿工所得到并记录在这个交易的区块链中。
- 交易链条与孤立交易：有时候子交易比父交易更早到达，那么节点会把自交易放在临时池中等待接收它的父交易，为了防止对比特币节点的DDOS攻击所以当孤立交易存储量到达上限的时候一个或者多个孤立交易会被随机挑选出来然后丢掉。
##### 5.6比特币交易脚本和脚本语言
- 比特币的交易引擎依赖于两类脚本来验证：一个锁定脚本和一个解锁脚本。锁定脚本是一个放在一个输出值上的障碍，往往包含着一个公钥。解锁脚本是一个解决或满足被锁定脚本在一个输出上设定的花费条件的脚本，是交易输出的一部分，往往包含一个被用户的比特币钱包（用户的私钥）生成的数字签名。


#### 比特币钱包  
使用比特币钱包的时候应当先使用强密码加密钱包；解锁钱包需要两个参数，密码和多久钱包再次被自动锁定；钱包地址：比特币钱包地址可以从一个比特币参考客户端维护的地址池里面获得一个公开接收地址；我们的交易将只能在minconf个确认之后才能看到数额；交易的输出需要签名， 而签名将利用钱包中的密钥，故而一个加密的钱包在使用之前必须要解密；  
私钥--》单向椭圆曲线相乘-->公钥-->哈希函数-->比特币地址；私钥需要保持机密以及被备份以保证账户不会被人盗取也不会丢失此账户；从一个随机数生成一个私钥，私钥可以是1-n-1之间的任何一个常数（n=1.158 * 10^77，略小于2^256）并由比特币所使用的椭圆曲线的阶所定义。一般来说是在一个密码学安全的随机源取出一长串的随机字节，使用SHA 256哈希算法运算产生一个256位的数字，若其小于n-1那么就是一个合适私钥；bitcoin并不能从公钥得知私钥，而读取私钥是因为密钥对都被储存在钱包里。  
通过椭圆曲线算法从私钥计算得到公钥是不可逆转的过程即K=k*G   k是私钥，G是被成为生成点的常数点，K就是所得的公钥，反响运算被称为寻找离散对数，是非常困难的。（椭圆曲线加密一个字都看不懂/sad）
公钥K被定义成一个K=（x，y）。***大多数比特币程序使用OpenSSL加密库进行椭圆曲线计算。例如，调用EC_POINT_mul() 函数，可计算得到公钥。***
比特币地址是一个由数字和字母组成的字符串，由公钥生成的比特币地址由数字1开头，比特币地址可由公钥经过单向的加密哈希算法得到。
***哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。加密哈希函数在比特币中被广泛使用：比特币地址、脚本地址以及在挖矿中的工作量证明算法。由公钥生成比特币地址时使用的算法是Secure Hash Algorithm (SHA)和the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)，特别是SHA256和RIPEMD160。

以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160 哈希值，得到一个长度为160比特（20字节）的数字：***
通常用户见到的比特币地址是经过“Base58Check”编码的（参见72页“Base58和Base58Check编码”一节），这种编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。  
Base58是一种基于文本的而简直编码格式，用在比特币和其它的加密货币中，是Base64编码的子集，使用大小写字谜和10个数字，但是去掉了Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。就是由不包括0o1i的大小写字母和数字组成。
Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。使用Base58check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行对比。二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。

为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来明确需要编码的数据的类型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。

计算“双哈希”校验码，意味着要对之前的结果（前缀和数据）运行两次SHA256哈希算法：也就是在数据前iaru版本前缀之后进行双HASH256计算后取前四字节作为校验码，最后进行Base58编码，校验即将base58解码取其中的数据重新进行计算然后进行校验。  
不同的编码格式，用于方便人们无误的使用和识别密钥如密钥有HEX WIF WIF-Compressed（压缩格式密钥）。  WIF（Wallet Import Format）钱包导入格式，版本前缀128  
WIF格式转换为HEX格式需要在末尾加 版本号128  而HEX需要末尾加上版本号才能转换到WIF格式。hex压缩格式密钥转换到WIF-compressed格式 需要在hex私钥后面加上后缀01  使用同上的方法即末尾再加上128的版本号在进行编码。生成的WIF压缩格式的密钥以字母K开头，用以表示被编码的16进制末尾有一个01  
公钥的格式：公钥是椭圆曲线上的一个坐标(x，y)组成，公钥通常表示为前缀04紧接着2个256比特的数字，第一个是256比特的x第二个是256比特的y，而前缀是用来表示是否是压缩格式 04是非压缩格式 03 02是压缩格式，压缩格式为02/03加256比特的x值，如果我们知道了x坐标就可以根据y2 mod p=（x3 +7）mod p得到Y坐标，但是y坐标有正负两个值，分别对应着奇数和偶数，用前缀02代表偶数，前缀03代表奇数。  520比特（包括前缀，x坐标，y坐标）16进制就是130比特
压缩格式私钥并不是私钥被压缩了而是只能用于产生压缩格式公钥
##### ***4.4 4.5 比特币钱包没有具体看完***  
